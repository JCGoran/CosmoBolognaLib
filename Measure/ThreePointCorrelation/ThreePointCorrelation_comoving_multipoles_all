// ============================================================================


void cbl::measure::threept::ThreePointCorrelation_comoving_multipoles::m_count_triplets_all (std::vector<double> &NN, std::vector<std::vector<std::vector<double>>> &NNN, std::vector<double> &RR, std::vector<std::vector<std::vector<double>>> &RRR, const double rmin, const double rmax, const int nbins, const int norders, const catalogue::Catalogue& catalogue) const
{
  /// Erase pair and triplet vectors
  NN.erase(NN.begin(), NN.end());
  NNN.erase(NNN.begin(), NNN.end());
  NN.resize(nbins, 0);
  NNN.resize(nbins, vector<vector<double>>(nbins, vector<double>(norders, 0)));

  RR.erase(RR.begin(), RR.end());
  RRR.erase(RRR.begin(), RRR.end());
  RR.resize(nbins, 0);
  RRR.resize(nbins, vector<vector<double>>(nbins, vector<double>(norders, 0)));

  auto cc = make_shared<Catalogue>(catalogue);

  chainmesh::ChainMesh_Catalogue cm;

  double deltaBin = (rmax-rmin)/double(nbins);
  double binSize_inv = 1./deltaBin;

  cm.set_par(rmax*0.5, cc, rmax*1.1);

  auto cat = cm.catalogue();

  const int nObjects = catalogue.nObjects();

  // start the multithreading parallelization
#pragma omp parallel num_threads(omp_get_max_threads())
  {
    SphericalHarmonics_Coefficients alm_n(norders, nbins+1);

    vector<double> _NN(nbins+1, 0);
    vector<vector<vector<double>>> _NNN(nbins, vector<vector<double>>(nbins+1, vector<double>(norders, 0)));

    SphericalHarmonics_Coefficients alm_r(norders, nbins+1);
    vector<double> _RR(nbins+1, 0);
    vector<vector<vector<double>>> _RRR(nbins, vector<vector<double>>(nbins+1, vector<double>(norders, 0)));

    // parallelized loop
#pragma omp for schedule(static, 2)
    for (int i=0; i<nObjects; i++)
    {
      alm_n.reset();

      double ixx = cat->xx(i);
      double iyy = cat->yy(i);
      double izz = cat->zz(i);
      double iww = cat->weight(i);

      if(iww<0)
	alm_r.reset();

      vector<long> close_objects = cm.close_objects({ixx, iyy, izz}, -1);

      for (size_t j=0; j<close_objects.size(); j++) {

	double jxx = cat->xx(close_objects[j]);
	double jyy = cat->yy(close_objects[j]);
	double jzz = cat->zz(close_objects[j]);
	double jww = cat->weight(close_objects[j]);

	double xx = jxx-ixx;
	double yy = jyy-iyy;
	double zz = jzz-izz;

	double rr = sqrt(xx*xx+yy*yy+zz*zz);

	if (rr>=rmin && rr<=rmax && i!=close_objects[j]) {

	  vector<complex<double>> _alm = alm_n.alm(xx/rr, yy/rr, zz/rr);

	  int jbin = max(0, min(int((rr-rmin)*binSize_inv), nbins));

	  _NN[jbin] += iww*jww;

	  alm_n.add (_alm, jww, jbin);
	  if (iww<0 && jww <0) {
	    alm_r.add(_alm, jww, jbin);
	    _RR[jbin] += iww*jww;
	  }
	}
      }

      for (int b1=0; b1<nbins; b1++)
	for (int b2=0; b2<nbins; b2++)
	  for (int l=0; l<norders; l++) {
	    _NNN[b1][b2][l] += iww*alm_n.power(l, b1, b2);
	    if (iww<0)
	      _RRR[b1][b2][l] -= iww*alm_r.power(l, b1, b2);
	  }
    }
#pragma omp critical
    {
      for (int b1=0; b1<nbins; b1++){
	NN[b1] += _NN[b1];
	RR[b1] += _RR[b1];
	for (int b2=0; b2<nbins; b2++)
	  for (int l=0; l<norders; l++) {
	    NNN[b1][b2][l] += _NNN[b1][b2][l];
	    RRR[b1][b2][l] += _RRR[b1][b2][l];
	  }
      }
    }

  }
}





// ============================================================================


cbl::measure::threept::ThreePointCorrelation_comoving_multipoles::ThreePointCorrelation_comoving_multipoles (const std::shared_ptr<cbl::catalogue::Catalogue> catalogue, const std::shared_ptr<cbl::catalogue::Catalogue> random_catalogue, const double rMin, const double rMax, const double binSize, const size_t nOrders)
{
  set_parameters(rMin, rMax, binSize, nOrders);
  set_catalogues(catalogue, random_catalogue);
}





// ============================================================================


void cbl::measure::threept::ThreePointCorrelation_comoving_multipoles::set_parameters (const double rMin, const double rMax, const double binSize, const size_t nOrders)
{
  m_rMin = rMin;
  m_rMax = rMax;
  m_binSize = binSize;
  m_nOrders = nOrders;
  m_isAllConf = true;
}
